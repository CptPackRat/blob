#!/usr/bin/env lua

local usage = [[
Usage:
    %s [options] OUTPUT INPUT...

Type '%s --help' for more information.
]]

local version = [[
Blob 1.0 Copyright (c) 2016 AdrianT
]]

local help = [[
Usage:
    %s --no-main [--lua=PATH] OUTPUT INPUT...
    %s --main-only [--lua=PATH] OUTPUT INPUT...

Options:
    --no-main   - Do not generate a main routine. Used when separate
                  source files are desired rather that a single blob,
                  or in projects that will provide their own main
                  routine.
    --main-only - Only generate a main routine. Used when separate
                  source files are desired rather than a single blob,
                  the generated routine will call the functions that
                  would otherwise have been generated for the supplied
                  input files.
    --lua=PATH  - Specify the path of the Lua interpreter to use when
                  producing bytecode. Used for projects that are to be
                  built against a different version of Lua to that of
                  the shell environment.
    --help      - Print this message.
    --version   - Print version string.
]]

local file_header = [[
/**
 * %s
 * Bytecode Blob precompiled for %s
 *
 * This file was auto-generated by Blob as part of
 * the build process. It should not be modified or
 * committed to revision control, and will probably
 * be removed by a 'make clean'.
**/

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
#include <stdbool.h>

]]

local func_header = [[
/**
 * luaopen_%s()
 * %s
**/
bool luaopen_%s(lua_State* L)
{
    const unsigned char blob[] = {
       ]]

local func_footer = [[

    };

    return !luaL_loadbuffer(L, (const char*)blob, sizeof(blob), %q) && !lua_pcall(L, 0, 0, 0);
}

]]

local func_proto = [[
bool luaopen_%s(lua_State* L);
]]

local main_header = [[
int main(int argc, char** argv)
{
    lua_State* L = luaL_newstate();
    luaL_openlibs(L);

    bool good = luaopen_%s(L)]]

local main_repeat = [[

             && luaopen_%s(L)]]

local main_footer = [[
;

    if (!good) {
        fprintf(stderr, "%s\n", lua_tostring(L, -1));
        return 1;
    }

    lua_getglobal(L, "main");
    if (lua_type(L, -1) != LUA_TFUNCTION) {
        fprintf(stderr, "No 'main' function, aborting.\n");
        return 1;
    }

    int a;
    for (a = 0; a < argc; a++) {
        lua_pushstring(L, argv[a]);
    }

    if (lua_pcall(L, argc, 1, 0)) {
        fprintf(stderr, "%s\n", lua_tostring(L, -1));
        return 1;
    }

    lua_close(L);
    return 0;
}

]]

function main()

    local inputs = {}
    local output = nil
    local noMain = false
    local onlyMain = false

    for index, arg in ipairs(arg) do
        local opt = arg:match("^%-%-(.+)$")
        if opt then
            if opt == "help" then
                showHelp()
            elseif opt == "version" then
                showVersion()
            elseif opt:match("^lua") then
                fallThru(opt, index)
            elseif opt == "no-main" then
                noMain = true
            elseif opt == "main-only" then
                onlyMain = true
            else
                error("Unrecognised option '--" .. opt .. "'.", 0)
            end
        else
            if not output then
                output = arg
            else
                inputs[#inputs + 1] = arg
            end
        end
    end

    if not output then
        error("No output file specified.", 0)
    end

    if #inputs < 1 then
        error("No input files specified.", 0)
    end

    if noMain and onlyMain then
        error("Cannot specify '--no-main' and '--main-only' at the same time.", 0)
    end

    local outFile = io.open(output, "w")
    if not outFile then
        error("Failed to open '" .. output .. "' for write.", 0)
    end

    --[[
        Produce cleaner names to use for functions:
         - Remove path components if present.
         - Remove '.lua' extension if present.
         - Replace any remaining unsafe chars with underscores.

        TODO: Add some logic to detect/handle collisions
              between clean names rather than leaving them
              for GCC to whinge about?
        TODO: Maybe add a way to specify the naming rules
              or just the names outright?
    ]]
    local names = {}
    for key, val in pairs(inputs) do
        val = val:match("[/\\]([^/\\]+)$") or val
        val = val:match("^([^%.]+)%.lua$") or val
        names[key] = val:gsub("%W+", "_")
    end

    outFile:write(file_header:format(output, _VERSION))

    --[[
        Write a luaopen_* function for each input file
        that will load a bytecode blob into the supplied
        lua machine, OR, write a prototype for that
        function if '--main-only' is enabled.
    ]]
    for key, val in pairs(inputs) do
        if onlyMain then
            outFile:write(func_proto:format(names[key]))
        else
            local loader, err = loadfile(val)
            if not loader then
                error("%s", err)
            end

            local blob = string.dump(loader)
            local len = #blob

            outFile:write(func_header:format(names[key], val, names[key]))
            for k, v in ipairs({blob:byte(1, len)}) do
                if (k % 16 == 0) and k < len then
                    outFile:write(string.format(" %3d,\n       ", v))
                else
                    outFile:write(string.format(" %3d,", v))
                end
            end
            outFile:write(func_footer:format(val))
        end
    end

    --[[
        Write a main routine that will create a new
        Lua state, load standard libraries, load the
        corresponding luaopen_* function for each of
        the input files.
    ]]
    if not noMain then
        if onlyMain then
            outFile:write("\n")
        end
        for key, val in pairs(names) do
            if key == 1 then
                outFile:write(main_header:format(val))
            else
                outFile:write(main_repeat:format(val))
            end
        end
        outFile:write(main_footer)
    end

    outFile:close()

end

--[[
    If we were given a specific Lua interpreter to
    use then we re-launch ourselves using that instead.

    TODO: The downside of this method is that it means
          that Blob is limited to only producing bytecode
          for Lua versions/builds that are capable of
          running Blob itself.
]]
function fallThru(opt, skip)

    local bin = opt:match("^lua=(.+)$")
    if not bin then
        error("Invalid option '--" .. opt .. "'.", 0)
    end

    local command = bin .. " " .. arg[0]
    for index, arg in ipairs(arg) do
        if index ~= skip then
            command = command .. " '" .. arg .. "'"
        end
    end

    local result, what, code = os.execute(command)
    if _VERSION == "Lua 5.1" then
        os.exit(result)
    else
        os.exit(what == "exit" and code or 1)
    end

end

local cleanName = arg[0]:match("[/\\]([^/\\]+)$") or arg[0]

function showHelp()
    io.stdout:write(version .. "\n")
    io.stdout:write(help:format(cleanName, cleanName, cleanName))
    os.exit(0)
end

function showVersion()
    io.stdout:write(version)
    os.exit(0)
end

local res, err = pcall(main)
if not res then
    io.stderr:write("Error: " .. err .. "\n")
    io.stderr:write(usage:format(cleanName, cleanName))
    os.exit(1)
end

